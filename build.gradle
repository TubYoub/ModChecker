plugins {
    id 'fabric-loom' version '1.11-SNAPSHOT'
    id 'maven-publish'
}

def targetMinecraftVersion = project.hasProperty('targetMinecraftVersion')
        ? project.getProperty('targetMinecraftVersion')
        : '1_21_6'

def getVersionProperty = { propertyName ->
    def specificProperty = "mc_${targetMinecraftVersion.replace('.', '_')}_${propertyName}"
    if (project.hasProperty(specificProperty)) {
        return project.getProperty(specificProperty)
    }
    throw new GradleException("Missing property: ${specificProperty} for target Minecraft version: ${targetMinecraftVersion}")
}

version = project.mod_version
group = project.maven_group
base {
    archivesName = "${project.archives_base_name}-${targetMinecraftVersion.replace('_', '.')}"
}

repositories {
    maven { url "https://maven.fabricmc.net/" }
}

dependencies {
    minecraft "com.mojang:minecraft:${getVersionProperty('minecraft_version')}"
    mappings "net.fabricmc:yarn:${getVersionProperty('yarn_mappings')}:v2"
    modImplementation "net.fabricmc:fabric-loader:${getVersionProperty('loader_version')}"
    modImplementation "net.fabricmc.fabric-api:fabric-api:${getVersionProperty('fabric_version')}"
}

processResources {
    inputs.property "version", project.version
    inputs.property "minecraft_version", getVersionProperty('minecraft_version')
    inputs.property "loader_version", getVersionProperty('loader_version')
    inputs.property "mod_version", project.mod_version
    filteringCharset "UTF-8"

    filesMatching("fabric.mod.json") {
        expand "version": project.version,
                "minecraft_version": getVersionProperty('minecraft_version'),
                "loader_version": getVersionProperty('loader_version'),
                "mod_version": project.mod_version
    }
}

def targetJavaVersion = 21
tasks.withType(JavaCompile).configureEach {
    it.options.encoding = "UTF-8"
    if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
        it.options.release.set(targetJavaVersion)
    }
}

java {
    def javaVersion = JavaVersion.toVersion(targetJavaVersion)
    if (JavaVersion.current() < javaVersion) {
        toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
    }
    withSourcesJar()
}

jar {
    from("LICENSE") {
        rename { "${it}_${project.archivesBaseName}" }
    }
}

publishing {
    publications {
        create("mavenJava", MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }
}

tasks.register('buildAllMinecraftVersions') {
    group = "build"
    description = "Builds the mod for all configured Minecraft versions and launches a test client for each one"

    // one clean at the very beginning
    dependsOn 'clean'

    doLast {
        def minecraftVersions = []
        project.properties.each { key, value ->
            if (key.startsWith('mc_') && key.endsWith('_minecraft_version')) {
                def versionId = key.substring(3, key.length() - '_minecraft_version'.length())
                minecraftVersions.add(versionId)
            }
        }

        if (minecraftVersions.isEmpty()) {
            logger.warn("No Minecraft versions configured in gradle.properties starting with 'mc_'.")
            return
        }

        // sort oldest â†’ newest
        minecraftVersions = minecraftVersions.sort(false) { a, b ->
            def aParts = a.replace('_', '.').split('\\.')
            def bParts = b.replace('_', '.').split('\\.')
            for (int i = 0; i < Math.min(aParts.size(), bParts.size()); i++) {
                int cmp = (aParts[i] as Integer).compareTo(bParts[i] as Integer)
                if (cmp != 0) return cmp
            }
            aParts.size() <=> bParts.size()
        }

        logger.lifecycle("Building & testing for Minecraft versions: ${minecraftVersions.collect { it.replace('_', '.') }.join(', ')}")

        def isWindows = System.getProperty("os.name").toLowerCase().contains("win")
        def gradlewCommand = isWindows ? "gradlew.bat" : "./gradlew"

        minecraftVersions.each { mcVer ->
            logger.lifecycle("=== Building for Minecraft ${mcVer.replace('_', '.')} ===")

            // 1. Build
            def buildCmd = [
                    gradlewCommand,
                    "build",
                    "-PtargetMinecraftVersion=${mcVer}"
            ].collect { it.toString() }

            def buildProc = new ProcessBuilder(buildCmd)
                    .directory(project.rootDir)
                    .redirectErrorStream(true)
                    .start()
            buildProc.inputStream.eachLine { println it }
            if (buildProc.waitFor() != 0) {
                throw new GradleException("Build failed for Minecraft ${mcVer.replace('_', '.')}")
            }

            logger.lifecycle("=== Launching test client for Minecraft ${mcVer.replace('_', '.')} ===")

            // 2. Run client
            def runCmd = [
                    gradlewCommand,
                    "runClient",
                    "-PtargetMinecraftVersion=${mcVer}"
            ].collect { it.toString() }

            def runProc = new ProcessBuilder(runCmd)
                    .directory(project.rootDir)
                    .redirectErrorStream(true)
                    .start()

            // Pipe output to console so you can see crashes
            runProc.inputStream.eachLine { println it }

            int exit = runProc.waitFor()
            if (exit != 0) {
                throw new GradleException("Test client crashed or exited with code $exit for Minecraft ${mcVer.replace('_', '.')}")
            }

            logger.lifecycle("=== Test client closed normally for Minecraft ${mcVer.replace('_', '.')} ===")
        }

        logger.lifecycle("All versions built and tested successfully!")
    }
}